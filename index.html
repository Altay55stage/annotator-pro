<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>YOLO Annotator</title>
    <style>
        :root {
            --app-bg-color: #f0f2f5;
            --card-bg-color: #ffffff;
            --primary-color: #007aff;
            --primary-text-color: #ffffff;
            --secondary-text-color: #8e8e93;
            --text-color: #1c1c1e;
            --border-color: #c6c6c8;
            --header-height: 50px;
            --bottom-action-bar-height: 60px;
            --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--app-bg-color);
            color: var(--text-color);
            font-size: 16px;
            overflow-x: hidden;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        .app-header {
            background-color: var(--card-bg-color);
            color: var(--text-color);
            height: var(--header-height);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: 600;
            border-bottom: 1px solid #e0e0e0;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .app-content {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            margin-top: var(--header-height);
            padding-bottom: calc(var(--bottom-action-bar-height) + var(--safe-area-inset-bottom) + 15px);
        }

        .card {
            background-color: var(--card-bg-color);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .card-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        .card-subtitle {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 0.95em;
            color: var(--text-color);
        }
        /* Custom file input label style */
        .file-input-label {
            display: block; /* Pour qu'il prenne toute la largeur */
            width: 100%;
            padding: 12px;
            border: 1px dashed var(--primary-color);
            border-radius: 8px;
            background-color: var(--app-bg-color);
            color: var(--primary-color);
            text-align: center;
            cursor: pointer;
            margin-bottom: 5px; /* Réduit si fileNameDisplay est en dessous */
            font-weight: 500;
        }

        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1em;
            background-color: #f8f8f8;
            margin-bottom: 15px;
        }
        /* input[type="file"] est caché, le label est utilisé */

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
            accent-color: var(--primary-color);
        }
        .checkbox-container label {
            margin-bottom: 0;
            font-weight: normal;
        }

        #modelStatus {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            text-align: center;
            padding: 5px 0;
        }

        /* MODIFIED/REVIEWED STYLES FOR IMAGE PREVIEW */
        .image-preview-container {
            width: 100%;
            min-height: 180px; /* Ajusté pour mobile */
            max-height: 45vh; /* Conserve une hauteur relative à la vue */
            background-color: #e9ecef;
            border-radius: 8px;
            display: flex; /* Utilisé pour centrer le placeholder */
            align-items: center;
            justify-content: center;
            margin-top: 10px; /* Un peu moins d'espace si fileNameDisplay est là */
            position: relative; /* Crucial pour le positionnement absolu des enfants */
            overflow: hidden; /* Empêche tout débordement */
        }

        #uploadedImageDisplay {
            display: none; /* Initialement caché, affiché par JS */
            /* width et height seront définis par JS pour maintenir l'aspect ratio */
            /* position: absolute et top/left seront définis par JS pour le centrage */
            object-fit: contain; /* Assure que l'image est contenue si ses dimensions JS sont plus grandes que l'espace réel */
        }

        #overlayCanvas {
            position: absolute; /* Positionné par rapport à .image-preview-container */
            /* top, left, width, height seront définis par JS */
            pointer-events: none;
            display: none; /* Initialement caché, affiché avec l'image */
        }
        .image-placeholder-text {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            text-align: center; /* S'assurer que le texte est centré */
        }
        /* END OF MODIFIED/REVIEWED STYLES FOR IMAGE PREVIEW */


        .log-output-card .card-title {
            margin-bottom: 8px;
        }
        pre {
            background-color: #e9ecef;
            border-radius: 6px;
            padding: 10px;
            font-size: 0.8em;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 150px;
            overflow-y: auto;
            color: #495057;
        }

        .app-bottom-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--card-bg-color);
            height: calc(var(--bottom-action-bar-height) + var(--safe-area-inset-bottom));
            padding-bottom: var(--safe-area-inset-bottom);
            display: flex;
            align-items: center;
            justify-content: space-around;
            border-top: 1px solid #e0e0e0;
            box-shadow: 0 -1px 5px rgba(0,0,0,0.08);
            z-index: 100;
        }

        .action-button {
            flex-grow: 1;
            padding: 10px 5px;
            background-color: var(--primary-color);
            color: var(--primary-text-color);
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            margin: 0 8px;
            height: 40px;
            line-height: 20px; /* Aide au centrage vertical du texte */
        }
        .action-button:disabled {
            background-color: #b0bec5;
            color: #e0e0e0;
            cursor: not-allowed;
        }
        .action-button.secondary {
            background-color: #e9ecef;
            color: var(--primary-color);
        }

        details {
            background-color: var(--card-bg-color);
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        details summary {
            padding: 15px;
            font-weight: 500;
            cursor: pointer;
            list-style-position: inside;
            border-bottom: 1px solid var(--app-bg-color);
        }
        details[open] summary {
            border-bottom: 1px solid #e0e0e0;
        }
        details .details-content {
            padding: 0 15px 15px 15px;
        }
        details summary::marker {
           color: var(--primary-color);
        }

        @media (min-width: 768px) {
            body { font-size: 14px; }
            .app-header { justify-content: flex-start; padding-left: 20px; }
            .app-content {
                max-width: 900px;
                margin: var(--header-height) auto 0 auto;
                padding: 20px;
                padding-bottom: 20px;
            }
            .app-bottom-actions { display: none; }

            .desktop-actions-container {
                display: flex;
                gap: 15px;
                margin-top: 20px;
            }
            .desktop-actions-container .action-button {
                margin: 0;
            }

            .main-layout-desktop {
                display: flex;
                gap: 20px;
            }
            .main-layout-desktop > .column {
                flex: 1;
            }
             .image-preview-container {
                max-height: 500px; /* Plus de hauteur sur desktop */
                min-height: 300px;
            }
            pre { max-height: 200px; }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            YOLO Annotator
        </header>

        <main class="app-content">
            <div class="main-layout-desktop">
                <div class="column">
                    <section class="card">
                        <h2 class="card-title">1. Configuration du Modèle</h2>
                        <label for="modelSelect">Modèle YOLO :</label>
                        <select id="modelSelect"></select>
                        <button id="loadModelBtn" class="action-button" style="width:100%; margin-top:10px; margin-left:0;">Charger Modèle</button>
                        <div id="modelStatus">Aucun modèle chargé</div>
                    </section>

                    <section class="card">
                        <h2 class="card-title">2. Image à Analyser</h2>
                        <label for="imageUpload" class="file-input-label">
                            Choisir une image
                        </label>
                        <input type="file" id="imageUpload" accept="image/*" style="display:none;">
                        <p class="card-subtitle" id="fileNameDisplay" style="text-align:center; margin-top:0; margin-bottom: 8px; min-height: 1.2em;"></p>
                        <div class="image-preview-container">
                            <img id="uploadedImageDisplay" src="#" alt="Aperçu de l'image">
                            <canvas id="overlayCanvas"></canvas>
                            <span class="image-placeholder-text" id="imagePlaceholder">Aucune image sélectionnée</span>
                        </div>
                    </section>
                </div>

                <div class="column">
                    <details>
                        <summary>Paramètres Avancés</summary>
                        <div class="details-content">
                            <fieldset style="border:none; padding:0; margin-top:15px;">
                                <legend style="font-weight:500; margin-bottom:10px;">YOLO Standard</legend>
                                <div>
                                    <label for="confidence">Confiance (0.01-1.0):</label>
                                    <input type="number" id="confidence" value="0.3" step="0.01" min="0.01" max="1.0">
                                </div>
                                <div>
                                    <label for="imgSize">Taille Image (inférence):</label>
                                    <input type="number" id="imgSize" value="640" step="32" min="32">
                                </div>
                                <div>
                                    <label for="nmsIou">NMS IoU:</label>
                                    <input type="number" id="nmsIou" value="0.45" step="0.01" min="0.01" max="1.0">
                                </div>
                                 <div>
                                    <label for="device">Device:</label>
                                    <select id="device">
                                        <option value="cuda">CUDA (si dispo)</option>
                                        <option value="cpu">CPU</option>
                                    </select>
                                </div>
                            </fieldset>
                            <fieldset style="border:none; padding:0; margin-top:20px;">
                                <legend style="font-weight:500; margin-bottom:10px;">SAHI (Optionnel)</legend>
                                <div class="checkbox-container">
                                    <input type="checkbox" id="useSahi">
                                    <label for="useSahi">Utiliser SAHI</label>
                                </div>
                                <div class="sahi-options" style="display:none;">
                                    <label for="sahiSliceHeight">Slice Height:</label>
                                    <input type="number" id="sahiSliceHeight" value="512">
                                    <label for="sahiSliceWidth">Slice Width:</label>
                                    <input type="number" id="sahiSliceWidth" value="512">
                                    <label for="sahiOverlapHeight">Overlap Height Ratio:</label>
                                    <input type="number" id="sahiOverlapHeight" value="0.2" step="0.01" min="0" max="0.99">
                                    <label for="sahiOverlapWidth">Overlap Width Ratio:</label>
                                    <input type="number" id="sahiOverlapWidth" value="0.2" step="0.01" min="0" max="0.99">
                                </div>
                            </fieldset>
                        </div>
                    </details>

                    <section class="card log-output-card">
                        <h2 class="card-title">Journal & Statut</h2>
                        <pre id="logOutput">Prêt.</pre>
                    </section>

                    <section class="card log-output-card">
                        <h2 class="card-title">Description LLM</h2>
                        <pre id="llmDescriptionOutput"></pre>
                    </section>
                </div>
            </div>

            <div class="desktop-actions-container">
                <button id="predictBtnDesktop" class="action-button" disabled>Lancer Analyse</button>
                <button id="describeLlmBtnDesktop" class="action-button secondary" disabled>Décrire avec LLM</button>
            </div>
        </main>

        <footer class="app-bottom-actions">
            <button id="predictBtn" class="action-button" disabled>Analyser</button>
            <button id="describeLlmBtn" class="action-button secondary" disabled>Décrire</button>
        </footer>
    </div>

    <script>
        // --- Éléments DOM ---
        const modelSelect = document.getElementById('modelSelect');
        const loadModelBtn = document.getElementById('loadModelBtn');
        const modelStatus = document.getElementById('modelStatus');
        
        const imageUploadInput = document.getElementById('imageUpload');
        const imageUploadLabel = document.querySelector('.file-input-label');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const uploadedImageDisplay = document.getElementById('uploadedImageDisplay');
        const imagePlaceholder = document.getElementById('imagePlaceholder');
        const imagePreviewContainer = document.querySelector('.image-preview-container'); // Ajouté
        const overlayCanvas = document.getElementById('overlayCanvas');
        const ctx = overlayCanvas.getContext('2d');

        const confidenceInput = document.getElementById('confidence');
        const imgSizeInput = document.getElementById('imgSize');
        const nmsIouInput = document.getElementById('nmsIou');
        const deviceSelect = document.getElementById('device');

        const useSahiCheckbox = document.getElementById('useSahi');
        const sahiOptionsDiv = document.querySelector('.sahi-options');
        const sahiSliceHeightInput = document.getElementById('sahiSliceHeight');
        const sahiSliceWidthInput = document.getElementById('sahiSliceWidth');
        const sahiOverlapHeightInput = document.getElementById('sahiOverlapHeight');
        const sahiOverlapWidthInput = document.getElementById('sahiOverlapWidth');

        const predictBtnMobile = document.getElementById('predictBtn');
        const describeLlmBtnMobile = document.getElementById('describeLlmBtn');
        const predictBtnDesktop = document.getElementById('predictBtnDesktop');
        const describeLlmBtnDesktop = document.getElementById('describeLlmBtnDesktop');
        
        const logOutput = document.getElementById('logOutput');
        const llmDescriptionOutput = document.getElementById('llmDescriptionOutput');

        const API_BASE_URL = 'https://cf57-193-55-66-31.ngrok-free.app'; // <--- METTRE À JOUR VOTRE URL NGROK ICI

        let currentImageFile = null;
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        // let imageDisplayWidth = 0; // Ces valeurs seront calculées dans adjustCanvasAndDraw
        // let imageDisplayHeight = 0;
        let lastDrawnBoxes = [];

        function logMessage(message, type = 'INFO') {
            const timestamp = new Date().toLocaleTimeString();
            const newLogEntry = `[${timestamp} ${type}] ${message}\n`;
            logOutput.textContent = newLogEntry + logOutput.textContent.substring(0, 5000);
            console.log(`[${type}] ${message}`);
        }

        function updateActionButtonsState() {
            const modelLoaded = modelStatus.textContent.startsWith('Modèle chargé:');
            const imageSelected = !!currentImageFile;
            const canPredict = modelLoaded && imageSelected;
            const canDescribe = imageSelected;

            [predictBtnMobile, predictBtnDesktop].forEach(btn => btn.disabled = !canPredict);
            [describeLlmBtnMobile, describeLlmBtnDesktop].forEach(btn => btn.disabled = !canDescribe);
        }

        document.addEventListener('DOMContentLoaded', () => {
            fetchModels();
            logMessage("Interface initialisée. API: " + API_BASE_URL, "SYSTEM");
            if (API_BASE_URL.includes("ngrok-free.app") && API_BASE_URL.includes("xxxxxxx")) { // Plus générique
                 logMessage("ASSUREZ-VOUS DE METTRE À JOUR API_BASE_URL avec votre URL ngrok !", "IMPORTANT_WARNING");
            } else if (API_BASE_URL === 'https://cf57-193-55-66-31.ngrok-free.app') {
                 logMessage("RAPPEL: L'URL API est une valeur d'exemple. Mettez à jour si c'est votre ancienne URL.", "WARNING");
            }
            updateActionButtonsState();

            if(imageUploadLabel) {
                imageUploadLabel.addEventListener('click', () => imageUploadInput.click());
            }
        });

        async function fetchModels() { /* ... (Identique à votre code) ... */
            logMessage('Chargement des modèles...');
            try {
                const response = await fetch(`${API_BASE_URL}/models`, { headers: {'ngrok-skip-browser-warning': 'true'} });
                if (!response.ok) throw new Error(`Serveur: ${response.status} ${await response.text()}`);
                const models = await response.json();
                modelSelect.innerHTML = models.map(m => `<option value="${m.name}">${m.name}</option>`).join('');
                logMessage(models.length > 0 ? `${models.length} modèles trouvés.` : 'Aucun modèle trouvé.', models.length > 0 ? 'SUCCESS' : 'WARNING');
                if (models.length === 0) modelStatus.textContent = "Aucun modèle sur serveur.";
            } catch (error) {
                logMessage(`Erreur chargement modèles: ${error.message}`, 'ERROR');
                modelStatus.textContent = "Erreur modèles.";
            }
        }

        loadModelBtn.addEventListener('click', async () => { /* ... (Identique à votre code) ... */
            const modelName = modelSelect.value;
            if (!modelName) { logMessage('Sélectionnez un modèle.', 'WARNING'); return; }
            
            logMessage(`Chargement: ${modelName}...`);
            modelStatus.textContent = `Chargement ${modelName}...`;
            loadModelBtn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/load_model`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
                    body: JSON.stringify({ model_name: modelName })
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.detail || `Serveur: ${response.status}`);
                modelStatus.textContent = `Modèle chargé: ${modelName}`;
                logMessage(`${modelName} chargé avec succès.`, 'SUCCESS');
            } catch (error) {
                modelStatus.textContent = "Erreur chargement.";
                logMessage(`Erreur chargement ${modelName}: ${error.message}`, 'ERROR');
            } finally {
                loadModelBtn.disabled = false;
                updateActionButtonsState();
            }
        });
        
        imageUploadInput.addEventListener('change', (event) => {
            currentImageFile = event.target.files[0];
            if (currentImageFile) {
                fileNameDisplay.textContent = currentImageFile.name;
                imagePlaceholder.style.display = 'none';
                // Ne pas afficher uploadedImageDisplay ou overlayCanvas ici, adjustCanvasAndDraw s'en chargera
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    uploadedImageDisplay.src = e.target.result;
                    // La magie opère dans uploadedImageDisplay.onload
                }
                reader.readAsDataURL(currentImageFile);

                // Mettre cet écouteur ici garantit qu'il est frais pour chaque nouvelle image
                uploadedImageDisplay.onload = () => {
                    originalImageWidth = uploadedImageDisplay.naturalWidth;
                    originalImageHeight = uploadedImageDisplay.naturalHeight;
                    
                    // Afficher l'image et le canvas maintenant qu'on a les dimensions
                    uploadedImageDisplay.style.display = 'block';
                    overlayCanvas.style.display = 'block';

                    adjustCanvasAndDraw(); // Calcule tailles et positions, puis dessine
                    lastDrawnBoxes = []; // Clear previous boxes for a new image
                    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); // Explicitement
                    logMessage(`Image "${currentImageFile.name}" chargée (${originalImageWidth}x${originalImageHeight}).`, 'INFO');
                };
                uploadedImageDisplay.onerror = () => {
                    logMessage("Erreur: Impossible de charger l'aperçu de l'image.", "ERROR");
                    resetImagePreview();
                };

            } else {
                resetImagePreview();
            }
            updateActionButtonsState();
        });

        function resetImagePreview() {
            fileNameDisplay.textContent = "";
            uploadedImageDisplay.style.display = 'none';
            overlayCanvas.style.display = 'none';
            imagePlaceholder.style.display = 'block';
            currentImageFile = null; // Important
            originalImageWidth = 0;
            originalImageHeight = 0;
            lastDrawnBoxes = [];
            if (ctx && overlayCanvas) { // S'assurer qu'ils existent
                 ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            }
        }


        useSahiCheckbox.addEventListener('change', () => { /* ... (Identique à votre code) ... */
            sahiOptionsDiv.style.display = useSahiCheckbox.checked ? 'block' : 'none';
        });

        async function handlePrediction() { /* ... (Identique à votre code, juste pour la complétude) ... */
             if (!currentImageFile || !modelStatus.textContent.startsWith('Modèle chargé:')) {
                logMessage('Chargez modèle et image.', 'WARNING'); return;
            }
            logMessage('Analyse en cours...', 'INFO');
            [predictBtnMobile, predictBtnDesktop].forEach(btn => btn.disabled = true);
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            lastDrawnBoxes = [];

            const params = {
                confidence: parseFloat(confidenceInput.value), img_size: parseInt(imgSizeInput.value),
                nms_iou: parseFloat(nmsIouInput.value), device: deviceSelect.value,
                use_sahi: useSahiCheckbox.checked, sahi_slice_height: parseInt(sahiSliceHeightInput.value),
                sahi_slice_width: parseInt(sahiSliceWidthInput.value),
                sahi_overlap_height_ratio: parseFloat(sahiOverlapHeightInput.value),
                sahi_overlap_width_ratio: parseFloat(sahiOverlapWidthInput.value),
            };
            const queryParams = new URLSearchParams(params);
            const finalPredictUrl = `${API_BASE_URL}/predict?${queryParams.toString()}`;
            const fileData = new FormData();
            fileData.append('file', currentImageFile);

            try {
                const response = await fetch(finalPredictUrl, {
                    method: 'POST', body: fileData, headers: {'ngrok-skip-browser-warning': 'true'}
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.detail || `Serveur: ${response.status}`);
                logMessage(`Analyse: ${result.boxes.length} boîtes trouvées.`, 'SUCCESS');
                lastDrawnBoxes = result.boxes;
                drawBoundingBoxes(lastDrawnBoxes); // Va utiliser les dimensions d'affichage calculées
            } catch (error) {
                logMessage(`Erreur prédiction: ${error.message}`, 'ERROR');
            } finally {
                updateActionButtonsState(); 
            }
        }
        predictBtnMobile.addEventListener('click', handlePrediction);
        predictBtnDesktop.addEventListener('click', handlePrediction);

        async function handleLlmDescription() { /* ... (Identique à votre code, juste pour la complétude) ... */
            if (!currentImageFile) {
                 logMessage('Téléchargez une image pour la description.', 'WARNING'); return;
            }
            logMessage('Description LLM en cours...', 'INFO');
            llmDescriptionOutput.textContent = 'En cours...';
            [describeLlmBtnMobile, describeLlmBtnDesktop].forEach(btn => btn.disabled = true);

            try {
                const reader = new FileReader();
                reader.readAsDataURL(currentImageFile);
                reader.onloadend = async () => {
                    const base64Image = reader.result.split(',')[1];
                    const response = await fetch(`${API_BASE_URL}/describe_llm`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'ngrok-skip-browser-warning': 'true' },
                        body: JSON.stringify({ image_base64: base64Image, prompt: "Décris cette image de manière concise." })
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.detail || `Erreur LLM (${response.status})`);
                    llmDescriptionOutput.textContent = result.description;
                    logMessage('Description LLM reçue.', 'SUCCESS');
                };
                reader.onerror = () => { throw new Error('Erreur lecture fichier pour LLM.'); };
            } catch (error) {
                logMessage(`Erreur LLM: ${error.message}`, 'ERROR');
                llmDescriptionOutput.textContent = `Erreur: ${error.message}`;
            } finally {
                 updateActionButtonsState();
            }
        }
        describeLlmBtnMobile.addEventListener('click', handleLlmDescription);
        describeLlmBtnDesktop.addEventListener('click', handleLlmDescription);

        // --- Canvas & Dessin ---
        // REVISED adjustCanvasAndDraw
        function adjustCanvasAndDraw() {
            if (!uploadedImageDisplay.complete || uploadedImageDisplay.naturalWidth === 0 || !currentImageFile) {
                // Si l'image n'est pas prête (ex: src juste défini mais pas encore chargé par le navigateur)
                // ou si currentImageFile est null (ex: après un reset)
                // On ne fait rien ou on cache, resetImagePreview gère le cas null.
                if (currentImageFile) {
                    requestAnimationFrame(adjustCanvasAndDraw); // Réessayer au prochain frame si une image est attendue
                }
                return;
            }
            
            const containerWidth = imagePreviewContainer.clientWidth;
            const containerHeight = imagePreviewContainer.clientHeight;

            const imgAspectRatio = originalImageWidth / originalImageHeight;
            
            let displayWidth, displayHeight;

            // Calculer les dimensions d'affichage pour s'adapter au conteneur tout en gardant le ratio
            if (containerWidth / containerHeight > imgAspectRatio) {
                // Le conteneur est plus large (ou moins haut) que l'image
                displayHeight = containerHeight;
                displayWidth = displayHeight * imgAspectRatio;
            } else {
                // Le conteneur est plus haut (ou moins large) que l'image
                displayWidth = containerWidth;
                displayHeight = displayWidth / imgAspectRatio;
            }
            
            // Appliquer les dimensions à l'image
            uploadedImageDisplay.style.width = `${displayWidth}px`;
            uploadedImageDisplay.style.height = `${displayHeight}px`;
            
            // Centrer l'image dans son conteneur (qui est flex et center)
            // n'est plus nécessaire avec la logique flex du parent si l'image
            // elle-même est un block. Mais si on la positionne en absolute:
            uploadedImageDisplay.style.position = 'absolute';
            uploadedImageDisplay.style.top = `${(containerHeight - displayHeight) / 2}px`;
            uploadedImageDisplay.style.left = `${(containerWidth - displayWidth) / 2}px`;

            // Ajuster le canvas pour qu'il corresponde exactement à l'image affichée
            overlayCanvas.width = displayWidth;
            overlayCanvas.height = displayHeight;
            overlayCanvas.style.top = uploadedImageDisplay.style.top; // Aligner avec l'image
            overlayCanvas.style.left = uploadedImageDisplay.style.left; // Aligner avec l'image
            
            // S'assurer qu'ils sont visibles (au cas où ils auraient été cachés)
            uploadedImageDisplay.style.display = 'block';
            overlayCanvas.style.display = 'block';

            drawBoundingBoxes(lastDrawnBoxes); // Redessiner avec les nouvelles dimensions
        }


        function drawBoundingBoxes(boxes) {
            if (!boxes || !overlayCanvas.width || !overlayCanvas.height) return; // S'assurer que le canvas a des dimensions
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            if (boxes.length === 0) return;

            ctx.strokeStyle = 'rgba(255, 59, 48, 0.9)';
            // Utiliser les dimensions actuelles du canvas pour lineWidth, pas imageDisplayWidth/Height globaux
            ctx.lineWidth = Math.max(1.5, Math.min(overlayCanvas.width, overlayCanvas.height) / 250);

            const scaleX = overlayCanvas.width / originalImageWidth;
            const scaleY = overlayCanvas.height / originalImageHeight;

            boxes.forEach(box => {
                ctx.strokeRect(box.x1 * scaleX, box.y1 * scaleY, (box.x2 - box.x1) * scaleX, (box.y2 - box.y1) * scaleY);
            });
        }
        
        window.addEventListener('resize', () => {
            if (currentImageFile && uploadedImageDisplay.style.display === 'block') { // Seulement si une image est affichée
                adjustCanvasAndDraw();
            }
        });

    </script>
</body>
</html>
